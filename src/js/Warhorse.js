/**
 * @file Warhorse.js
 * @description The main Warhorse daemon.
 * @author Kyle Alexis Sargeant <kasargeant@gmail.com> {@link https://github.com/kasargeant https://github.com/kasargeant}.
 * @copyright Kyle Alexis Sargeant 2017
 * @license See LICENSE file included in this distribution.
 */

"use strict";

// Imports
const child = require("child_process");
const fs = require("fs");
const path = require("path");

const glob = require("glob");
const merge = require("merge");
const shell = require("shelljs");
const tar = require("tar");

// Helpers (external)
const Git = require("./helpers/GitHelper");
const Cli = require("./helpers/CliHelper");

// Default templates
const packageBase = require("../conventions/package_base.json");
const packageSnippets = require("../conventions/package_snippets.json");

// Setup console
const Pageant = require("pageant");
const console = new Pageant();
const color = require("tinter");

// Helpers (internal)
// Failure-tolerant version of fs.mkdirSync(dirPath) - won't overwrite existing dirs!!!
const mkdirSync = function(dirPath) {
    try {
        fs.mkdirSync(dirPath);
    } catch(err) {
        if(err.code !== "EEXIST") {throw err;}
    }
};

// Failure-tolerant version of fs.unlinkSync(filePath) - won't crash if no file already exists!!!
const unlinkSync = function(filePath) {
    try {
        fs.unlinkSync(filePath);
    } catch(err) {
        console.error(err.code);
    }
};

/**
 * @class
 * @classdesc The main Warhorse class, containing all actions available to automate tasks and builds.
 */
class Warhorse {
    /**
     * The Warhorse constructor takes an options object.  In these options are contained the user requested
     * configuration defaults for the project.  If there are no options - then Warhorse's own default
     * configuration settings will be used instead.
     * @constructor
     * @param {string} moduleDirectory - Directory where this file's module is.
     * @param {string} workingDirectory - Directory where this code was originally invoked from.
     * @param {Object} options - Configuration options to override Warhorse's own defaults.
     * @param {boolean} useDebug - Flag to initiate verbose debug operation.
     */
    constructor(moduleDirectory, workingDirectory, options = {}, useDebug = false) {
        this.defaults = {
            
            language: "es51", //"es51", "es2015", "es2015+JSX"

            bundle: {
                debug: false,
                useOutput: "stdout",
                useEqualsSign: false,
                src: "src/index.js",
                dst: "dist/index.js"
            },
            clean: {},
            compress: {
                css: {
                    src: "dist/css/index.min.css",
                    dst: "dist/css/index.min.css.tar.gz"
                },
                js: {
                    src: "dist/js/index.min.js",
                    dst: "dist/js/index.min.js.tar.gz"
                },
                gif: {
                    src: "./test/data/client_src/img/gif/*.gif",
                    dst: "./dist/img/gif"
                },
                jpg: {
                    src: "./test/data/client_src/img/jpg/*.jpg",
                    dst: "./dist/img/jpg"
                },
                png: {
                    src: "./test/data/client_src/img/png/*.png",
                    dst: "./dist/img/png"
                },
                svg: {
                    src: "./test/data/client_src/img/svg/*.svg",
                    dst: "./dist/img/svg"
                },
                txt: {
                    src: "dist/js/index.min.js",
                    dst: "dist/js/index.js.tar.gz"
                }
            },
            create: {
                name: "Untitled",
                version: "0.0.0",
                description: "A new project generated by the Warhorse task runner.",
                keywords: ["javascript"],
                author: "undefined",
                email: "undefined@undefined.com",
                license: "GPL-3.0"
            },
            document: {
                js: {
                    conf: "./conf/jsdoc.json",
                    src: "./src/index.js",
                    dst: "./docs/api",
                    useOutput: "stdout"
                }
            },
            lint: {
                js: {
                    style: require("../../conf/jscs.json"),
                    quality: require("../../conf/jshint.json")
                }
            },
            load: {
                encoding: "utf8"
            },
            minify: {
                css: {
                    debug: false,
                    useOutput: "stdout",
                    useEqualsSign: false,
                    src: "src/css/index.css",
                    dst: "dist/css/index.min.css"
                },
                js: {
                    debug: false,
                    useOutput: "stdout",
                    useEqualsSign: false,
                    src: "src/js/index.js",
                    dst: "dist/js/index.js"
                }
            },
            pack: {
                gif: {},
                jpg: {},
                png: {},
                svg: {}
            },
            preprocess: {
                less: {
                    src: "src/index.less",
                    dst: "dist/index.css"
                },
                sass: {
                    src: "src/css/index.sass",
                    dst: "dist/css/index.min.css"
                }
            },
            postprocess: {
                css: {
                    src: "src/css/index.css"
                }
            },
            process: {
                includePaths: ["./src/sass"]
            },
            rename: {},
            save: {
                compress: false,
                encoding: "utf8"
            },
            test: {
                js: {
                    bayeux: {
                        src: "test/js/*.test.js"
                    },
                    jest: {
                        config: "./conf/jest.json"
                    }
                }
            }
        };
        this.settings = Object.assign(this.defaults, options);
        this.debug = useDebug;

        this.lintStatsJS = {reports: [], errors: 0, warnings: 0};

        this.commands = ["build", "clean", "create", "distribute", "document", "lint", "pack", "process", "publish", "test"]; //FIXME - replace with Object.keys(warhorse.tasks);
        this.conventions = ["module", "web"];

        this.cmds = {}; // Lookup for built-in commands.

        this.moduleDirectory = moduleDirectory;     // i.e. Warhorse's own directory
        this.conventionsDirectory = moduleDirectory + "src/conventions/";

        this.projectDirectory = ""; // i.e. root of user project and location of _warhorse.js
        this.workingDirectory = workingDirectory;   // Current working directory... usually same as projectDirectory or a test directory.

        this.file = null; // Main arg passed from function to function - requires sync operation of course!

        // Finally add user-defined tasks...
        try {
            // ...from a user-defined file
            this.cmds = require(this.workingDirectory + "/_warhorse.js")(this);
        } catch(ex) {
            // ...or otherwise, fall-back on default
            this.cmds = require(this.moduleDirectory + "/_warhorse.js")(this);
            // console.debug("Warning: This directory is missing a '_warhorse.js' file and is uninitialised.");
        }
        // Finally, finally, slip built-in 'create' into cmds
        this.cmds.create = this._cmdCreate;
    }

    /**
     * Clean/ delete file(s) task.
     * @param {Array} paths - Array of paths or files to empty and delete.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    clean(paths, options = {}) {
        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Cleaning project...`);}

        shell.rm("-rf", ...paths);
        console.h4(`Done.`);
    }

    /**
     * Copy file(s) task.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    copy(type, options = {}) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Bundling ${type.toUpperCase()}...`);}

        if(options.recurse === true) {
            shell.cp("-R", options.src, options.dst);
        } else {
            shell.cp(options.src, options.dst);
        }
        console.h4(`Done.`);
    }

    /**
     * Task for bundling and module resolution.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @param {string} options.exclude - Exclude file(s) from the task.
     * @param {string} options.include - Include file(s) for the task.
     * @returns {Object} - Returns self for chaining.
     */
    bundle(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Bundling ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "js") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.bundle, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                debug: this.debug || config.debug,   // i.e. debug/source map options
                config: config.conf,
                outfile: config.dst,
                exclude: config.exclude,
                external: config.include,
                recurse: true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/browserify", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for compressing files of any type. e.g. JS, CSS, TXT. [NOTE: CURRENTLY OUTPUTS .tar.gz ONLY.]
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    compress(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Compressing ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(["css", "js", "txt"].includes(type)) {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.compress[type], options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                sync: true,
                gzip: true,
                cwd: this.workingDirectory,
                file: config.dst
            };

            // NOTE: There is no user->tool mapping necessary here.
            // Directly execute the task.
            tar.c(toolOptions, toolArgs);

        } else if(["gif", "jpg", "png", "svg"].includes(type)) {
            // NOTE: This is different to every other task.  here we use the same task code for all the different
            //       image types.
            const plugins = {
                "gif": "gifsicle",
                "jpg": "jpegtran",
                "png": "pngquant",
                "svg": "svgo"
            };
            let plugin = plugins[type];
            if(plugin !== undefined) {

                // Create a user-level config from defaults/options
                let config = Object.assign(this.defaults.compress[type], options);

                // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
                let toolArgs = [config.src];
                let toolOptions = {
                    map: this.debug || config.debug,   // i.e. debug/source map options
                    "out-dir": config.dst,
                    plugin: plugin
                };

                // Finally map configuration to tool args and options
                this._execute(this.moduleDirectory, "./node_modules/.bin/imagemin", this.workingDirectory, toolArgs, toolOptions, config);
            }
        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for automatically documenting project source code.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    document(type, options) {
        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Documenting ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "js") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.document.js, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            // NOTE: We always use Warhorse conf file.
            let src = path.resolve(this.workingDirectory, config.src);
            let dst = path.resolve(this.workingDirectory, config.dst);
            let configPath = path.resolve(this.moduleDirectory, "./conf/jsdoc.json");
            let toolArgs = [src];
            let toolOptions = {
                verbose: this.debug || config.debug,   // i.e. debug/source map options
                configure: configPath,
                destination: dst,
                recurse: true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/jsdoc", this.moduleDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for automatically documenting project source code.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.conf - The path to a separate configuration file for this task.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    documentLocal(type, options) {
        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Documenting ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "js") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.document.js, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            // NOTE: IF an external configuration file is provided - ALL other configurations (except debug) are ignored.
            let toolArgs, toolOptions;
            if(config.conf === undefined) {
                toolArgs = [config.src];
                toolOptions = {
                    verbose: this.debug || config.debug,   // i.e. debug/source map options
                    destination: config.dst,
                    recurse: true
                };
            } else {
                toolArgs = [];
                toolOptions = {
                    verbose: this.debug || config.debug,   // i.e. debug/source map options
                    configure: config.conf
                };
            }

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/jsdoc", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for linting source and template code. e.g. JS, LESS, SASS.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @param {string} options.exclude - Exclude file(s) from the task.
     * @param {string} options.include - Include file(s) for the task.
     * @returns {Object} - Returns self for chaining.
     */
    lint(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Linting ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "js" && options.type === "style") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.lint.js.style, options);
            config.useOutput = "jscs";
            config.useEqualsSign = true;
            config.stdio = "pipe"; // Needed to return raw data

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                // verbose: this.debug || config.debug,   // i.e. debug/source map options
                config: config.conf,
                reporter: "json"
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/jscs", this.workingDirectory, toolArgs, toolOptions, config);

        } else if(type === "js" && options.type === "quality") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.lint.js.style, options);
            config.useOutput = "jshint";
            config.useEqualsSign = true;
            config.stdio = "pipe"; // Needed to return raw data

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                "source-map": this.debug || config.debug,   // i.e. debug/source map options
                config: config.conf,
                "exclude-path": config.exclude,
                reporter: path.resolve(this.moduleDirectory, "./node_modules/jshint-json/json.js")
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/jshint", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for minifying distributed code. e.g. JS, CSS.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @param {string} options.exclude - Exclude a file from the output bundle. Can be globs.
     * @param {string} options.include - Include a file from another bundle. Can be globs.
     * @returns {Object} - Returns self for chaining.
     */
    minify(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Minifying ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "js") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.minify.js, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                verbose: this.debug || config.debug,   // i.e. debug/source map options
                "config-file": config.conf,
                output: config.dst,
                compress: true,
                mangle: true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/uglifyjs", this.workingDirectory, toolArgs, toolOptions, config);

        } else if(type === "css") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.minify.css, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src];
            let toolOptions = {
                debug: this.debug || config.debug,   // i.e. debug/source map options
                map: this.debug || config.debug,   // i.e. debug/source map options
                input: config.src,
                output: config.dst
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/csso", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;

    }

    /**
     * Task for preprocessing template code. e.g. Handlebars, LESS, SASS.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @param {string} options.exclude - Exclude file(s) from the task.
     * @param {string} options.include - Include file(s) for the task.
     * @returns {Object} - Returns self for chaining.
     */
    preprocess(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Preprocessing ${type.toUpperCase()}...`);}

        // Select sub-task based on data type
        if(type === "less") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.preprocess.less, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src, config.dst];
            let toolOptions = {
                "source-map": this.debug || config.debug,   // i.e. debug/source map options
                "include-path": config.include,
                "relative-urls": true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/lessc", this.workingDirectory, toolArgs, toolOptions, config);

        } else if(type === "sass") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.preprocess.sass, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src, config.dst];
            let toolOptions = {
                "source-map": this.debug || config.debug,   // i.e. debug/source map options
                "include-path": config.include,
                "relative-urls": true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/node-sass", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for packing (minifying) source assets. e.g. GIF, JPG, PNG, SVG.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    pack(type, options) {
        // TODO - Reuse or remove 'pack' command.

        // Return self for chaining.
        return this;
    }

    /**
     * Task for post-processing source code. e.g. CSS.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    postprocess(type, options) {
        if(type === "css") {

            // Create a user-level config from defaults/options
            let config = Object.assign(this.defaults.preprocess.less, options);

            // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
            let toolArgs = [config.src, config.dst];
            let toolOptions = {
                map: this.debug || config.debug,   // i.e. debug/source map options
                config: config.conf,
                replace: true
            };

            // Finally map configuration to tool args and options
            this._execute(this.moduleDirectory, "./node_modules/.bin/postcss", this.workingDirectory, toolArgs, toolOptions, config);

        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * TODO: IMPLEMENT Task for publishing the distribution to cloud services. e.g. NPM.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.dst - The destination/target path for this task.
     * @returns {Object} - Returns self for chaining.
     */
    publish(type, options) {}

    /**
     *
     * @param {Object} reports - Lint style reports to be displayed.
     * @returns {void}
     * @private
     */
    _reportJSCS(reports) {
        // { 'test/data/client_src/js/Circle.js':
        //     [ { line: 9,
        //         column: 21,
        //         message: 'validateQuoteMarks: Invalid quote mark found' } ],
        //         'test/data/client_src/js/Polygon.js': [],
        //     'test/data/client_src/js/Square.js': [],
        //     'test/data/client_src/js/index.js': [] }
        // console.error(reports);

        let issuesTotal = 0;
        console.log("");
        console.log(`  Lint Report (JS style):`);
        console.log("");

        for(let reportIdx in reports) {

            // Extract each report.
            let report = reports[reportIdx];
            let filename = reportIdx;

            if(report.length === 0) {
                console.log(`    ${color.green("âœ“")} '${filename}' ok.`);
            } else {
                console.log(`    ${color.red("âœ•")} '${filename}' - ${report.length} issue(s):`);
                for(let i = 0; i < report.length; i++) {
                    let result = report[i];

                    let line = result.line;
                    let column = result.column;
                    let msg = result.message;

                    issuesTotal++;
                    console.log(`        at line: ${line} col: ${column} - ${msg}.`);
                }
                console.log("");
            }
        }
        // console.log(`Test Report Summary:`);
        // console.log(`   \x1b[32mTests passed: (${testsPassed}/${testsTotal})\x1b[0m`);
        // if(testsFailed) {
        //     console.log(`   \x1b[31mTests failed: (${testsFailed}/${testsTotal})\x1b[0m`);
        // }
        // console.log("");
    }

    /**
     *
     * @param {Object} reports - Lint quality reports to be displayed.
     * @returns {void}
     * @private
     */
    _reportJSHint(reports) {
        // {
        //     "result": [{
        //     "file": "test.js",
        //     "error": {
        //         "id": "(error)",
        //         "raw": "'{a}' is not defined.",
        //         "code": "W117",
        //         "evidence": "describe('jshint-json', function () {",
        //         "line": 6,
        //         "character": 1,
        //         "scope": "(main)",
        //         "a": "describe",
        //         "reason": "'describe' is not defined."
        //     }
        // }, {
        //     "file": "test.js",
        //     "error": {
        //         "id": "(error)",
        //         "raw": "'{a}' is not defined.",
        //         "code": "W117",
        //         "evidence": "\tit('should be used by JSHint', function () {",
        //         "line": 7,
        //         "character": 5,
        //         "scope": "(main)",
        //         "a": "it",
        //         "reason": "'it' is not defined."
        //     }
        // }],
        //     "data": [{
        //     "functions": [{
        //         "name": "\"jshint-json\"",
        //         "line": 6,
        //         "character": 35,
        //         "last": 26,
        //         "lastcharacter": 2,
        //         "metrics": {
        //             "complexity": 1,
        //             "parameters": 0,
        //             "statements": 1
        //         }
        //     }, {
        //         "name": "\"should be used by JSHint\"",
        //         "line": 7,
        //         "character": 46,
        //         "last": 25,
        //         "lastcharacter": 6,
        //         "metrics": {
        //             "complexity": 1,
        //             "parameters": 0,
        //             "statements": 5
        //         }
        //     }],
        //     "options": {
        //         "node": true,
        //         "esnext": true,
        //         "bitwise": true,
        //         "camelcase": true,
        //         "curly": true,
        //         "eqeqeq": true,
        //         "immed": true,
        //         "indent": 4,
        //         "(explicitIndent)": true,
        //         "latedef": true,
        //         "newcap": true,
        //         "noarg": true,
        //         "quotmark": "single",
        //         "regexp": true,
        //         "undef": true,
        //         "unused": true,
        //         "strict": true,
        //         "trailing": true,
        //         "smarttabs": true,
        //         "maxerr": 50
        //     },
        //     "errors": [{
        //         "id": "(error)",
        //         "raw": "'{a}' is not defined.",
        //         "code": "W117",
        //         "evidence": "describe('jshint-json', function () {",
        //         "line": 6,
        //         "character": 1,
        //         "scope": "(main)",
        //         "a": "describe",
        //         "reason": "'describe' is not defined."
        //     }, {
        //         "id": "(error)",
        //         "raw": "'{a}' is not defined.",
        //         "code": "W117",
        //         "evidence": "\tit('should be used by JSHint', function () {",
        //         "line": 7,
        //         "character": 5,
        //         "scope": "(main)",
        //         "a": "it",
        //         "reason": "'it' is not defined."
        //     }],
        //     "implieds": [{
        //         "name": "describe",
        //         "line": [
        //             6
        //         ]
        //     }, {
        //         "name": "it",
        //         "line": [
        //             7
        //         ]
        //     }],
        //     "globals": [
        //         "assert",
        //         "require",
        //         "jshint",
        //         "jsonReporter",
        //         "console"
        //     ],
        //     "member": {
        //         "run": 1,
        //         "reporter": 2,
        //         "log": 2,
        //         "args": 1
        //     },
        //     "file": "test.js"
        // }]
        // }

        // First we need to reduce and collate JSHint's verbose output.
        let reportsByFilename = {};
        reports = reports.result;
        for(let report of reports) {
            //console.log(">>" + report);
            if(reportsByFilename[report.file] === undefined) {
                reportsByFilename[report.file] = [report.error];
            } else {
                reportsByFilename[report.file].push(report.error);
            }
        }
        reports = reportsByFilename;
        // console.error(reports);

        console.log("");
        console.log(`  Lint Report (JS quality):`);
        console.log("");

        let reportFilenames = Object.keys(reports);
        for(let i = 0; i < reportFilenames.length; i++) {

            let filename = reportFilenames[i];
            console.log(`    ${color.red("âœ•")} '${filename}' has issue(s):`);

            // Extract each issue report.
            // {
            //         "id": "(error)",
            //         "raw": "'{a}' is not defined.",
            //         "code": "W117",
            //         "evidence": "describe('jshint-json', function () {",
            //         "line": 6,
            //         "character": 1,
            //         "scope": "(main)",
            //         "a": "describe",
            //         "reason": "'describe' is not defined."
            // }
            let report = reports[filename];
            for(let j = 0; j < report.length; j++) {
                let issue = report[j];
                console.log(`        at line: ${issue.line} col: ${issue.character} - ${issue.reason}.`);
            }



        }
        // console.log(`Test Report Summary:`);
        // console.log(`   \x1b[32mTests passed: (${testsPassed}/${testsTotal})\x1b[0m`);
        // if(testsFailed) {
        //     console.log(`   \x1b[31mTests failed: (${testsFailed}/${testsTotal})\x1b[0m`);
        // }
        // console.log("");
    }

    _reportTape(reports) {
        let testsTotal = 0;
        let testsFailed = 0;
        let testsPassed = 0;

        for(let testIdx = 0; testIdx < reports.length; testIdx++) {
            // Extract each report.
            let report = reports[testIdx];
            testsTotal += report.tests.length;

            console.log("");
            console.log(`  Test Report: ${report.name} (${report.tests.length} tests).`);
            for(let i = 0; i < report.tests.length; i++) {
                let result = report.tests[i];

                let filename = result.file;
                let line = result.line;
                let column = result.column;

                if(result.ok === true) {
                    // e.g. {"id":0,"ok":true,"name":"it should have assigned the right height.","operator":"equal","objectPrintDepth":5,"actual":210,"expected":210,"test":0,"type":"assert"}
                    testsPassed++;
                    console.log(`    [32mâœ“[0m ${result.name}`);
                } else {
                    // e.g. {"id":2,"ok":false,"name":"it should have assigned the right area.","operator":"equal","objectPrintDepth":5,"actual":44100,"expected":441100,"error":{},"functionName":"Test.<anonymous>","file":"/Users/kasargeant/dev/projects/warhorse/test/data/client_test/js/tape.js:17:8","line":17,"column":"8","at":"Test.<anonymous> (/Users/kasargeant/dev/projects/warhorse/test/data/client_test/js/tape.js:17:8)","test":0,"type":"assert"}
                    testsFailed++;
                    console.log(`    [31mâœ•[0m FAILED: ${result.name}`);
                    console.log(`        Testing: '${result.operator}'`);
                    console.log(`        at line: ${line} col: ${column} in '${filename}'.`);
                    console.log(`        - expected: '${result.expected}'`);
                    console.log(`        - actual  : '${result.actual}'`);
                    console.log("");
                }
            }
        }
        console.log(`Test Report Summary:`);
        console.log(`   [32mTests passed: (${testsPassed}/${testsTotal})[0m`);
        if(testsFailed) {
            console.log(`   [31mTests failed: (${testsFailed}/${testsTotal})[0m`);
        }
        console.log("");
    }

    /**
     * Task for testing code. e.g. JS.
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.src - The source path for this task.
     * @param {string} options.coverage - Report on unit coverage.
     * @param {string} options.update - Update any test snapshots.
     * @returns {Object} - Returns self for chaining.
     */
    test(type, options) {

        // Log task execution
        if(options.isSilent !== true) {console.h2(`TASK: Testing ${type.toUpperCase()} with '${options.tooling}'...`);}

        // Select sub-task based on data type
        if(type === "js") {

            // Select test framework to use
            if(options.tooling === "bayeux") {

                // Create a user-level config from defaults/options
                let config = Object.assign(this.defaults.test.js.bayeux, options);

                // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
                let toolArgs = [config.src];
                let toolOptions = {
                    verbose: this.debug || config.debug,   // i.e. debug/source map options
                    config: config.conf
                };

                // Finally map configuration to tool args and options
                this._execute(this.moduleDirectory, "./node_modules/.bin/bayeux", this.workingDirectory, toolArgs, toolOptions, config);

            } else if(options.tooling === "tape") {
                // Create a user-level config from defaults/options
                let defaults = {
                    src: "test/js/*.test.js"
                };
                let config = Object.assign(defaults, options);

                // Resolve tool-level arguments - with that user-level config
                let toolArgs = "";
                if(config.src !== undefined) {
                    toolArgs += config.src;
                }

                // NOTE: THIS SCRIPT HAS NO OPTIONS
                let toolOptions = {};

                // let cmdLine = `node ${this.moduleDirectory}src/js/tools/TapeRunner.js ${toolArgs}`;
                let cmdLine = `node ${toolArgs}`;

                // Finally map configuration to tool args and options
                let stdout = "{}";
                try {
                    stdout = child.execSync(cmdLine);
                } catch(ex) {
                    stdout = ex.stdout;
                }
                // At this point, stdout should contain an array of 0 or more test report objects.
                if(stdout !== null) {
                    let reportLines = stdout.toString().split("\n");
                    let reports = [];
                    let data = {
                        name: "Untitled test",
                        tests: []
                    };
                    let row = {};
                    for(let i = 0; i < reportLines.length; i++) {
                        try {
                            // console.log(">> " + reportLines[i]); // DEBUG ONLY
                            row = JSON.parse(reportLines[i]);
                            //console.log("-> " + JSON.stringify(row));
                            switch(row.type) {
                                case "test":
                                    data.id = row.id;
                                    data.name = row.name;
                                    break;
                                case "assert":
                                    data.tests.push(row);
                                    break;
                                case "end":
                                    reports.push(data);
                                    data = {
                                        name: "Untitled test",
                                        tests: []
                                    };
                                    break;
                                default:
                                    console.error(`Error: Unrecognised TAP message of type '${row.type}'.`);
                            }
                        } catch(ex) {
                            console.error(ex);
                            //console.log("IGNORING: " + reportLines[i]);
                        }
                    }

                    this._reportTape(reports);
                }


            } else if(options.tooling === "jest") {

                // Create a user-level config from defaults/options
                let config = Object.assign(this.defaults.test.js.jest, options);
                config.useInherit = true;

                // Resolve tool-level cmd-line toolArguments and toolOptions - with that user-level config
                // let toolArgs = [config.src];
                // let toolOptions = {
                //     verbose: this.debug || config.debug,   // i.e. debug/source map options
                //     config: config.conf
                // };
                // NOTE: IF an external configuration file is provided - ALL other configurations (except debug) are ignored.
                let toolArgs, toolOptions;
                if(config.conf === undefined) {
                    toolArgs = [config.src];
                    toolOptions = {
                        verbose: this.debug || config.debug,   // i.e. debug/source map options
                        coverage: true
                    };
                } else {
                    toolArgs = [];
                    toolOptions = {
                        verbose: this.debug || config.debug,   // i.e. debug/source map options
                        config: config.conf
                    };
                }

                // Finally map configuration to tool args and options
                this._execute(this.moduleDirectory, "./node_modules/.bin/jest", this.workingDirectory, toolArgs, toolOptions, config);
            }
        } else {
            console.error(`Error: Unrecognised type '${type}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task for controlling VCSs. e.g. GIT
     * @param {string} type - Type of source file.
     * @param {Object=} options - Options to override or extend this task's default configuration.
     * @param {string} options.debug - Enable debug reporting and/or (if available) source-maps.
     * @param {string} options.action - The versioning action to execute.
     * @returns {Object} - Returns self for chaining.
     */
    version(type, options) {
        switch(options.action) {
            case "get-branch-name":
                console.h3("On branch: " + Git.getCurrentBranchName());
                break;
            case "update-master":
                Git.updateMaster(options.release, options.comment);
                break;
            default:
                console.error(`Error: Unrecognised versioning action '${type}'.`);
        }
    }

    _cmdCreateInner(convention, answers) {

        if(answers.warhorse === undefined) {
            console.error("Error: Create command failed.");
            return;
        }

        // console.log("\nProject construction summary:");
        console.log(JSON.stringify(answers, null, "  "));

        let config = Object.assign(packageBase, answers);

        if(this.conventions.includes(convention)) {

            // Create convention infrastructure
            console.h2(`Creating infrastructure for convention '${convention}'.`);
            let projectPath = this.workingDirectory + config.name + "/";
            shell.cp("-R", `${this.conventionsDirectory}${convention}/`, projectPath);

            // Create a package.json for the new project
            let packageNew = Object.assign(packageBase, config);

            this.commands.map(function(cmdName) {
                packageNew.scripts[cmdName] = `warhorse ${cmdName}`;
            });

            delete packageNew.warhorse;

            let str = JSON.stringify(packageNew, null, 2); // spacing level = 2
            fs.writeFileSync(projectPath + "package.json", str);

            // Create a license for the project
            let license = config.license;
            let licensePath = `${this.conventionsDirectory}_licenses/${license}.txt`;
            fs.writeFileSync(projectPath + "LICENSE", fs.readFileSync(licensePath));

            // Move into the new project directory
            this.workingDirectory = projectPath;
            process.chdir(this.workingDirectory);

            // Install dependencies with a standard NPM install
            let stdout = child.execSync(`npm install`);
            if(stdout) {
                console.log(stdout.toString());
            }

        } else {
            console.warn("Warning: No Convention selected.  Exiting.");
        }
    }

    /**
     * Built-in 'create' command.  Starts an interactive session and then initialises a project similar to npm's 'init'.
     * @param {string} convention - Name of the project layout convention to follow.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdCreate(convention) {

        const questions = require(`./interactions/questions_${convention}`);

        let answers = questions();
        this._cmdCreateInner(convention, answers);

        // Return self for chaining.
        return this;

    }

    /**
     * Create project (using the defined convention) action.
     * @param {Object} options - Options to further configure this action.
     * @returns {void}
     * @private
     */
    _initModule(options = {}) {

        let srcPath = this.conventionsDirectory + "module/*";
        shell.cp("-R", srcPath, "./");
        let stdout = child.execSync(`npm install`);
        if(stdout) {
            console.log(stdout.toString());
        }
    }

    /**
     * Load action.  Loads files being used for processing by the action that follows.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    load(options = {}) {

        let config = Object.assign(this.settings.load, options);

        // Accepts a single filepath only.
        let srcPath = this.file.path + this.file.name;
        console.h3(`Loading file: ${this.file.path + this.file.name}`);

        this.file.content = fs.readFileSync(srcPath, config.encoding);

        // Return self for chaining.
        return this;
    }
    
    /**
     * Rename task.  Allows modification/replacement/injection of file details into the sequence of actions.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    rename(options = {}) {

        console.h3(`Renaming file: ${this.file.path}`);

        let config = Object.assign(this.settings.save, options);

        // Rename (i.e. overwrite) any values in the file object with the user-defined options object
        this.file = Object.assign(this.file, config);

        // Return self for chaining.
        return this;
    }

    /**
     * Splits a file path into its component parts.
     * @param {string} filePath - A standard system file or path name.
     * @returns {Object} - An object containing a destructured hash of the path's parts.
     * @private
     */
    _splitPath(filePath) {

        // Sanity check
        if(!filePath) {return null;}

        //console.h4(`Splitting file path: ${filePath}`); // e.g. /docs/index.html  // DEBUG ONLY

        let name = path.posix.basename(filePath);           // e.g. index.html
        let directory = path.dirname(filePath) + "/";       // e.g. /docs/
        let stem = name.slice(0, name.lastIndexOf("."));    // e.g. index
        let extension = path.extname(filePath);             // e.g. .html

        // console.log(`name: ${name}`);
        // console.log(`directory: ${directory}`);
        // console.log(`stem: ${stem}`);
        // console.log(`extension: ${extension}`);

        // Is it a config file e.g. .jshintrc
        let config = false;
        if(extension === "" && name.length > 0 && name[0] === "." && name.slice(-2) === "rc") {
            config = true;
        }
        return {
            original: filePath,
            path: directory, // Note: We use 'directory' to avoid nameclash with the module of the same name.
            name: name,
            stem: stem,
            extension: extension,
            config: config
        };
    }

    /**
     * Save action.
     * @param {string} dstPath - The file path that this file will be saved to.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    save(dstPath, options = {}) {

        let config = Object.assign(this.settings.save, options);

        console.h3(`Saving file to: ${dstPath}`);

        if(config.compress === true) {
            fs.writeFileSync(dstPath, this.file.content, config.encoding);
            child.execSync(`tar -zcvf ${dstPath + ".tar.gz"} ${dstPath}`);
        } else {
            fs.writeFileSync(dstPath, this.file.content, config.encoding);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task 'wrapper' function (used exclusively in '_warhorse.js' file).  Wraps an action, or list of actions, to be followed by the named task.
     * @param {string} desc - Title or description of the task.
     * @param {string} name - Name of the task tool.
     * @param {Object} options - Options to further configure this task.
     * @param {string|Array} args - Argument(s) for this task.
     * @param {string} useOutput - Flag indicating that task should display any output returned by the task.
     * @param {boolean} useEqualsSign - Use '=' sign between configuration key-values.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _execute(warhorseDirectory, relativeExecutablePath, workingDirectory, args=[], argOptions={}, options={}) {

        // First make sure that certain default options are set for sucessful command line operation.
        let defaults = {debug: false, useOutput: "stdout", stdio: "inherit", useEqualsSign: false};
        options = Object.assign(defaults, options);

        // Next, define working directory TODO - Maybe this can be removed... as we now pass CWD directly the child process?
        workingDirectory = path.resolve(workingDirectory);
        if(workingDirectory !== process.cwd()) {
            console.log("Current working directory was: >>" + process.cwd() + "<<");
            try {
                process.chdir(workingDirectory);
                console.log("Changed working directory to: >>" + process.cwd() + "<<");
            }
            catch(err) {
                throw err;
            }
        }

        // Construct final cmdLine.
        let executablePath = path.resolve(this.moduleDirectory, relativeExecutablePath);
        let cmdLine = Cli._compileCmdLine(executablePath, args, argOptions, options);
        if(options.debug) {console.log("Executing: " + cmdLine);}
        // if(true) {console.log("Executing: " + cmdLine);}

        let stdout = null; let stderr = null;
        try {
            stdout = child.execSync(cmdLine, {cwd: workingDirectory, stdio: options.stdio});
        } catch(ex) {
            //console.error(ex.message);
            stdout = ex.stdout;
            stderr = ex.stderr;
        }

        if(stdout !== null) {
            let output = "";
            switch(options.useOutput) {
                case "silent":
                    // console.log(">> SILENT");
                    break;
                case "stdout":
                    console.log(stdout.toString());
                    break;
                case "jscs":
                    output = stdout.toString();
                    if(output) {
                        output = JSON.parse(stdout.toString());
                        this._reportJSCS(output);
                    } else {
                        console.log("Nothing to report.");
                    }
                    break;
                case "jshint":
                    output = stdout.toString();
                    if(output) {
                        output = JSON.parse(stdout.toString());
                        this._reportJSHint(output);
                    } else {
                        console.log("Nothing to report.");
                    }
                    break;
                case "tape":
                    // console.log(">> TAPE");
                    this._reportTape(stdout.toString());
                    break;
                default:
                    // console.log(">> STDOUT");
                    console.log(stdout.toString());
            }
        }

        // Return self for chaining.
        return this;
    }


    /**
     * Private helper for load().
     * @param {string} globPath - A filename, filepath or globpath.
     * @param {Function} task - The task to be executed.
     * @param {Object} options - Options to further configure the task actions.
     * @returns {void}
     * @private
     */
    _use(globPath, task, options) {
        //console.h3(`Parsing: ${globPath}`);

        // Sync filesystem check
        let filePaths = glob.sync(globPath);
        if(filePaths.constructor === Array && filePaths.length > 0) {
            for(let filePath of filePaths) {
                this.file = this._splitPath(filePath);
                task(options);
            }
        } else {
            console.warn("No files matched.");
        }
    }

    /**
     * Executes the named command or task.
     * @param {string} name - Name of the command or task to execute.
     * @returns {Object} - Returns self for chaining.
     */
    execute(name) {
        if(this.commands.includes(name)) {
            let cmd = this.cmds[name];
            if(cmd !== null) {cmd();}
            return this;    // Return self for chaining.
        } else {
            console.error(`Error: Unrecognised command '${name}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute command from the CLI.
     * @param {string} args - Arguments passed from the command line interface.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    cli(args) {
        console.log(color.inverse(`WARHORSE active.`));
        let [cmdName, convention="module"] = args;

        console.h1(`COMMAND ${cmdName}`);

        // Handle the 'create' built-in separately
        if(cmdName === "create") {
            if(this.conventions.includes(convention)) {
                this._cmdCreate(convention);
            } else {
                console.error(`Error: Unrecognised project convention: '${convention}'.`);
            }
            return null; // Success or fail - nothing to return.
        } else {
            // Handle standard built-ins
            let cmd = this.cmds[cmdName];
            if(cmd !== null) {
                //console.log("Executing command type: " + typeof cmd);
                cmd();
            }
        }

        console.log(color.inverse(`WARHORSE done.`));

        // Return self for chaining.
        return this;
    }
}

// Exports
module.exports = Warhorse;

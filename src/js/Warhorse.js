/**
 * @file Warhorse.js
 * @description The main Warhorse daemon.
 * @author Kyle Alexis Sargeant <kasargeant@gmail.com> {@link https://github.com/kasargeant https://github.com/kasargeant}.
 * @copyright Kyle Alexis Sargeant 2017
 * @license See LICENSE file included in this distribution.
 */

"use strict";

// Imports
const child = require("child_process");
const fs = require("fs");
const path = require("path");

const glob = require("glob");
const merge = require("merge");
const shell = require("shelljs");

// const browserify = require("browserify");
const csso = require("csso");
const jscs = require("jscs");
const jshint = require("jshint").JSHINT;

//const less = require("less");
const sass = require("node-sass");
const uglify = require("uglify-es");

// Default templates
const packageBase = require("../conventions/package_base.json");
const packageSnippets = require("../conventions/package_snippets.json");

// Setup console
const Pageant = require("pageant");
const console = new Pageant();
// const color = console.Color;

process.env.TINTER_TEST = "256";
const color = require("tinter");

// const color = {
//     style: function(arg) {return arg;},
//     inverse: function(arg) {return arg;},
//     cyan: function(arg) {return arg;},
//     red: function(arg) {return arg;},
//     yellow: function(arg) {return arg;}
// }; // Create alias

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Warhorse specific
console.cmd = function(value) {
    console.log(color.style(value, "white", "navy", "italic"));
};
console.task = function(value) {
    value = "  " + color.style(value, "orange", "navy", "italic");
    console.log(value);
};
console.action = function(value) {
    // value = "  - " + color.redBg(value);
    value = "  - " + color.gray(value);
    console.log(value);
};
console.stage = function(value) {
    value = "    -> " + color.green(value);
    console.log(value);
};

// Failure-tolerant version of fs.mkdirSync(dirPath) - won't overwrite existing dirs!!!
const mkdirSync = function(dirPath) {
    try {
        fs.mkdirSync(dirPath);
    } catch(err) {
        if(err.code !== "EEXIST") {throw err;}
    }
};

// Failure-tolerant version of fs.unlinkSync(filePath) - won't crash if no file already exists!!!
const unlinkSync = function(filePath) {
    try {
        fs.unlinkSync(filePath);
    } catch(err) {
        console.error(err.code);
    }
};

/**
 * @class
 * @classdesc The main Warhorse class, containing all actions available to automate tasks and builds.
 */
class Warhorse {
    /**
     * The Warhorse constructor takes an options object.  In these options are contained the user requested
     * configuration defaults for the project.  If there are no options - then Warhorse's own default
     * configuration settings will be used instead.
     * @constructor
     * @param {string} moduleDirectory - Directory where this file's module is.
     * @param {string} workingDirectory - Directory where this code was originally invoked from.
     * @param {Object} options - Configuration options to override Warhorse's own defaults.
     * @param {boolean} useDebug - Flag to initiate verbose debug operation.
     */
    constructor(moduleDirectory, workingDirectory, options = {}, useDebug = false) {
        this.defaults = {
            
            language: "es51", //"es51", "es2015", "es2015+JSX"

            bundle: {
            },
            clean: {},
            document: {
                src: "./src",
                dst: "./docs/api"
            },
            init: {
                name: "Untitled",
                version: "0.0.0",
                description: "A new project generated by the Warhorse task runner.",
                keywords: ["javascript"],
                author: "undefined",
                email: "undefined@undefined.com",
                license: "GPL-3.0"
            },
            lint: {
                js: {
                    style: require("../../conf/jscs.json"),
                    syntax: require("../../conf/jshint.json")
                }
            },
            load: {
                encoding: "utf8"
            },
            minify: {},
            pack: {
                gif: {},
                jpg: {},
                png: {},
                svg: {}
            },
            precompile: {
                includePaths: ["./src/sass"]
            },
            rename: {},
            save: {
                compress: false,
                encoding: "utf8"
            },
            test: {
                config: "./conf/jest.json"
            }
        };
        this.settings = Object.assign(this.defaults, options);
        this.debug = useDebug;

        this.linterJSStyle = new jscs();
        this.linterJSStyle.registerDefaultRules();
        // this.linterJSStyle.configure(confJSCS);
        this.linterJSSyntax = jshint; // Note: JSHint is IFFY.
        this.linterJSStats = {reports: [], errors: 0, warnings: 0};

        this.commands = ["build", "clean", "create", "distribute", "document", "init", "lint", "pack", "precompile", "test"]; //FIXME - replace with Object.keys(warhorse.tasks);
        this.conventions = ["module", "web"];

        this.cmds = {}; // Lookup for built-in commands.
        this.tasks = {}; // Lookup for user-defined tasks.

        this.moduleDirectory = moduleDirectory;
        this.conventionsDirectory = moduleDirectory + "src/conventions/";
        this.workingDirectory = workingDirectory;

        this.file = null; // Main arg passed from function to function - requires sync operation of course!

        // Finally add user-defined tasks.
        try {
            // const configureTasks = require(workingDirectory + "/_warhorse.js");
            // configureTasks(this);
            const userConfig = require(workingDirectory + "/_warhorse.js")(this);
            this.cmds = userConfig.commands;
            this.tasks = userConfig.tasks;
        } catch(ex) {
            // fs.writeFileSync(workingDirectory + "/_warhorse.js", )
            console.warn("Warning: This directory is missing a '_warhorse.js' file and is uninitialised.");
        }
    }

    /**
     * Bundle action.
     * @param {Array} paths - Array of paths or files to empty and delete.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    clean(paths, options = {}) {
        console.action(`Cleaning project of generated files.`);
        shell.rm("-rf", ...paths);
        console.stage(`Done.`);
    }

    /**
     * Built-in 'build' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdBuild() {
        let cmd = this.cmds["build"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'clean' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdClean() {
        let cmd = this.cmds["clean"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    _cmdCreateInner(convention, answers) {

        if(answers.warhorse === undefined) {
            console.error("Error: Create command failed.");
            return;
        }

        // console.log("\nProject construction summary:");
        console.log(JSON.stringify(answers, null, "  "));

        let config = Object.assign(packageBase, answers);

        if(this.conventions.includes(convention)) {

            // Create convention infrastructure
            console.task(`Creating infrastructure for convention '${convention}'.`);
            let projectPath = this.workingDirectory + config.name + "/";
            shell.cp("-R", `${this.conventionsDirectory}${convention}/`, projectPath);

            // Create a package.json for the new project
            let packageNew = Object.assign(packageBase, config);

            this.commands.map(function(cmdName) {
                packageNew.scripts[cmdName] = `warhorse ${cmdName}`;
            });

            packageNew.warhorse.toolingTest = "jest";// FIXME - REMOVE THIS HACK AS SOON AS JASMINE/MOCHA FUNCTIONALITY IN PLACE!!!
            switch(packageNew.warhorse.toolingTest) {
                case "jasmine":
                    console.warn("Jasmine testing unimplemented."); // TODO - Jasmine implementation
                    // unlinkSync(projectPath + "/conf/jest.json");
                    // unlinkSync(projectPath + "/conf/mocha.json");
                    break;
                case "jest":
                    packageNew = merge.recursive(true, packageNew, packageSnippets.jest);
                    unlinkSync(projectPath + "/conf/jasmine.json");
                    // unlinkSync(projectPath + "/conf/mocha.json");
                    break;
                case "mocha":
                    console.warn("Mocha testing unimplemented."); // TODO - Mocha implementation
                    // unlinkSync(projectPath + "/conf/jasmine.json");
                    // unlinkSync(projectPath + "/conf/jest.json");
                    break;
                default:
                    console.warn("No test tool selected.");
            }

            delete packageNew.warhorse;

            let str = JSON.stringify(packageNew, null, 2); // spacing level = 2
            fs.writeFileSync(projectPath + "package.json", str);

            // Create a license for the project
            let license = config.license;
            let licensePath = `${this.conventionsDirectory}_licenses/${license}.txt`;
            fs.writeFileSync(projectPath + "LICENSE", fs.readFileSync(licensePath));

            // Move into the new project directory
            this.workingDirectory = projectPath;
            process.chdir(this.workingDirectory);

            // Install dependencies with a standard NPM install
            let stdout = child.execSync(`npm install`);
            if(stdout) {
                console.log(stdout.toString());
            }

        } else {
            console.warn("Warning: No Convention selected.  Exiting.");
        }
    }

    /**
     * Built-in 'create' command.  Starts an interactive session and then initialises a project similar to 'init'.
     * @param {string} convention - Name of the project layout convention to follow.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdCreate(convention) {

        const questions = require(`./interactions/questions_${convention}`);

        let answers = questions();
        this._cmdCreateInner(convention, answers);

        // Return self for chaining.
        return this;

    }

    /**
     * Create project (using the defined convention) action.
     * @param {Object} options - Options to further configure this action.
     * @returns {void}
     * @private
     */
    _initModule(options = {}) {

        let srcPath = this.conventionsDirectory + "module/*";
        shell.cp("-R", srcPath, "./");
        let stdout = child.execSync(`npm install`);
        if(stdout) {
            console.log(stdout.toString());
        }
    }

    /**
     * Create project (using the defined convention) action.
     * @param {string} convention - Name of the project layout convention to follow.
     * @param {Object} options - Options to further configure this command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdInit(convention, options = {scripts: {}}) {


        // Create a package.json for the new project
        this.commands.map(function(cmdName) {
            options.scripts[cmdName] = `warhorse ${cmdName}"`;
        });

        let packageNew = Object.assign(packageBase, options);


        switch(convention) {
            case "module":
                this._initModule(options);
                break;
            default:
                console.error("Error: Unrecognised or missing project convention.");
        }


        // Write package.json file for new project
        let str = JSON.stringify(packageNew, null, 2); // spacing level = 2
        fs.writeFileSync("packageNEW.json", str);

        //
        // // Resolve configuration
        // let config = Object.assign(this.settings.init, options);
        //
        // // Create NPM package configuration
        // const packageDefault = require("../default/package.json");
        // let packageProject = Object.assign(packageDefault, config);
        //
        // let convention = "default";
        // console.log(` * Creating project from convention: ${convention}`);
        // console.log(`   - Working directory: ${process.cwd()}`);
        //
        // // Fault-tolerant version of fs.mkdirSync(dirPath) - won't overwrite existing dirs!!!
        // const mkdirSync = function(dirPath) {
        //     try {
        //         fs.mkdirSync(dirPath);
        //     } catch(err) {
        //         if(err.code !== "EEXIST") {throw err;};
        //     }
        // };
        //
        // // Fault-tolerant version of fs.unlinkSync(filePath) - won't crash if no file already exists!!!
        // const unlinkSync = function(filePath) {
        //     try {
        //         fs.unlinkSync(filePath);
        //     } catch(err) {
        //         console.error(err.code);
        //         // if(err.code !== "EEXIST") {throw err};
        //     }
        // };
        //
        // // Create project directory structure
        // //FIXME - Guard can be removed once function is fully implemented.
        // let workingDirectory = this.settings.workingDirectory;
        // if(workingDirectory === "/Users/kasargeant/dev/projects/warhorse") {
        //     mkdirSync("./temp");
        //
        //     mkdirSync("./temp/conf");
        //
        //     mkdirSync("./temp/dist");
        //
        //     mkdirSync("./temp/docs");
        //     mkdirSync("./temp/docs/api");
        //     mkdirSync("./temp/docs/coverage");
        //     mkdirSync("./temp/docs/tests");
        //     mkdirSync("./temp/docs/linters");
        //
        //     mkdirSync("./temp/src");
        //     mkdirSync("./temp/src/css");
        //     mkdirSync("./temp/src/img");
        //     mkdirSync("./temp/src/js");
        //
        //     mkdirSync("./temp/test");
        //
        //     // Write NPM package definition
        //     let packageJson = JSON.stringify(packageProject, null, 4);
        //     unlinkSync("./temp/package.json");
        //     fs.writeFileSync("./temp/package.json", packageJson, "utf8");
        //     console.log(packageJson);
        //
        //     // Create configuration files
        //     const configJSCS = require("../default/conf/jscsrc.json");
        //     fs.writeFileSync("./temp/conf/.jscsrc", JSON.stringify(configJSCS, null, 4));
        //
        //     const configJSHINT = require("../default/conf/jshintrc.json");
        //     fs.writeFileSync("./temp/conf/.jshintrc", JSON.stringify(configJSHINT, null, 4));
        // }


        // Return self for chaining.
        return this;
    }


    /**
     * Built-in 'distribute' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdDistribute() {
        let cmd = this.cmds["distribute"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'document' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdDocument() {
        let cmd = this.cmds["document"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'fix' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdFix() {
        let cmd = this.cmds["fix"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'lint' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdLint() {
        let cmd = this.cmds["lint"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'pack' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdPack() {
        let cmd = this.cmds["pack"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'precompile' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdPrecompile() {
        let cmd = this.cmds["precompile"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Built-in 'test' command.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _cmdTest() {
        let cmd = this.cmds["test"];
        if(cmd !== null) {cmd();}
        return this;    // Return self for chaining.
    }

    /**
     * Load action.  Loads files being used for processing by the action that follows.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    load(options = {}) {

        let config = Object.assign(this.settings.load, options);

        // Accepts a single filepath only.
        let srcPath = this.file.path + this.file.name;
        console.action(`Loading file: ${this.file.path + this.file.name}`);

        this.file.content = fs.readFileSync(srcPath, config.encoding);

        // Return self for chaining.
        return this;
    }

    /**
     * Minify JS action.  Minimisation for ES51/ES2015 JavaScript.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    minifyJS(options = {}) {

        console.action(`Minifying JS from: ${this.file.path}`);

        let config = Object.assign(this.settings.bundle, options);

        // Process the data
        let processed = uglify.minify(this.file.content);
        this.file.content = processed.code;

        // let processed = uglify.minify(this.file.content, {
        //     sourceMap: {
        //         filename: "out.js",
        //         url: "out.js.map"
        //     }
        // });
        // console.log(processed.map);  // source map
        // console.log(processed.code); // minified output


        // Return self for chaining.
        return this;
    }
    
    /**
     * Rename action.  Allows modification/replacement/injection of file details into the sequence of actions.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    rename(options = {}) {

        console.action(`Renaming file: ${this.file.path}`);

        let config = Object.assign(this.settings.save, options);

        // Rename (i.e. overwrite) any values in the file object with the user-defined options object
        this.file = Object.assign(this.file, config);

        // Return self for chaining.
        return this;
    }

    /**
     * Splits a file path into its component parts.
     * @param {string} filePath - A standard system file or path name.
     * @returns {Object} - An object containing a destructured hash of the path's parts.
     * @private
     */
    _splitPath(filePath) {

        // Sanity check
        if(!filePath) {return null;}

        //console.stage(`Splitting file path: ${filePath}`); // e.g. /docs/index.html  // DEBUG ONLY

        let name = path.posix.basename(filePath);           // e.g. index.html
        let directory = path.dirname(filePath) + "/";       // e.g. /docs/
        let stem = name.slice(0, name.lastIndexOf("."));    // e.g. index
        let extension = path.extname(filePath);             // e.g. .html

        // console.log(`name: ${name}`);
        // console.log(`directory: ${directory}`);
        // console.log(`stem: ${stem}`);
        // console.log(`extension: ${extension}`);

        // Is it a config file e.g. .jshintrc
        let config = false;
        if(extension === "" && name.length > 0 && name[0] === "." && name.slice(-2) === "rc") {
            config = true;
        }
        return {
            original: filePath,
            path: directory, // Note: We use 'directory' to avoid nameclash with the module of the same name.
            name: name,
            stem: stem,
            extension: extension,
            config: config
        };
    }

    /**
     * Save action.
     * @param {string} dstPath - The file path that this file will be saved to.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    save(dstPath, options = {}) {

        let config = Object.assign(this.settings.save, options);

        console.action(`Saving file to: ${dstPath}`);

        if(config.compress === true) {
            fs.writeFileSync(dstPath, this.file.content, config.encoding);
            child.execSync(`tar -zcvf ${dstPath + ".tar.gz"} ${dstPath}`);
        } else {
            fs.writeFileSync(dstPath, this.file.content, config.encoding);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Command 'wrapper' function (used exclusively in '_warhorse.js' file).  Wraps a task, or list of tasks, to be executed by the named command.
     * @param {string} name - Name of the task.
     * @param {string} cmdFn - A function containing the tasks executed for this command.
     * @returns {void}
     */
    command(name, cmdFn) {
        this.cmds[name] = cmdFn;
    }

    /**
     * Task 'wrapper' function (used exclusively in '_warhorse.js' file).  Wraps an action, or list of actions, to be followed by the named task.
     * @param {string} desc - Title or description of the task.
     * @param {string} name - Name of the task tool.
     * @param {Object} options - Options to further configure this task.
     * @param {string|Array} args - Argument(s) for this task.
     * @param {boolean} showOutput - Flag indicating that task should display any output returned by the task.
     * @param {boolean} useEqualsSign - Use '=' sign between configuration key-values.
     * @returns {Object} - Returns self for chaining.
     */
    task(desc, name, options={}, args="", showOutput=true, useEqualsSign=false) {
        console.task(`TASK: ${desc}`);

        let cmdLine = this.moduleDirectory + "node_modules/.bin/" + name;

        let cmdLineArgs = "";
        if(args.constructor === Array) {
            for(let argc = 0; argc < args.length; argc++) {
                cmdLineArgs += " " + args[argc];
            }
        } else {
            cmdLineArgs = " " + args;
        }

        // Convert object to string
        let cmdLineOpts = "";
        let keyValDel = (useEqualsSign === true) ? "=" : " ";
        for(let key in options) {
            cmdLineOpts += ` --${key}${keyValDel}${options[key]}`;
        }

        cmdLine += cmdLineArgs + cmdLineOpts;

        if(this.debug) {console.log("Executing: " + cmdLine);}

        let stdout = "";
        try {
            stdout = child.execSync(cmdLine, {stdio: "inherit"});
            if(stdout !== null && showOutput === true) {
                console.log(stdout.toString());
            }
        } catch(ex) {
            console.error(ex.message);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Private helper for load().
     * @param {string} globPath - A filename, filepath or globpath.
     * @param {Function} task - The task to be executed.
     * @param {Object} options - Options to further configure the task actions.
     * @returns {void}
     * @private
     */
    _use(globPath, task, options) {
        //console.action(`Parsing: ${globPath}`);

        // Sync filesystem check
        let filePaths = glob.sync(globPath);
        if(filePaths.constructor === Array && filePaths.length > 0) {
            for(let filePath of filePaths) {
                this.file = this._splitPath(filePath);
                task(options);
            }
        } else {
            console.warn("No files matched.");
        }
    }

    /**
     * Use function identfies which files are to be used with which task
     * @param {string} taskName - The name of the task to be executed for every batch item.
     * @param {string} filePath - File path (globs/wildcards allowed) to be processed by this action.
     * @param {Object} options - Options are propagated to all task actions.
     * @returns {Object} - Returns self for chaining.
     */
    use(taskName, filePath, options = {}) {

        console.task(`TASK: ${taskName}`);

        // Retrieve task from the taskName
        let task = this.tasks[taskName];

        // If there are is no filePath to be sourced...
        if(filePath === undefined) {
            task();
        }

        // If it is a batch of filePaths...
        else if(filePath.constructor === Array) {
            filePath.map(function(filePathItem) {
                this._use(filePathItem, task, options);}.bind(this)
            );
        }

        // Else if it is single filePath.
        else if(typeof filePath === "string") {
            this._use(filePath, task, options);
        }
        // Otherwise...
        else {
            console.error(`Error: Unrecognisable or null filepath: ${filePath}`);
        }

        // Return self for chaining.
        return this;
    }


    /**
     * Execute command from the CLI.
     * @param {string} name - Name of the command to execute.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _executeCmd(name) {
        switch(name) {
            case "build": this._cmdBuild(); break;
            case "clean": this._cmdClean(); break;
            case "create": this._cmdCreate(); break;
            case "distribute": this._cmdDistribute(); break;
            case "document": this._cmdDocument(); break;
            case "fix": this._cmdFix(); break;
            case "init": this._cmdInit(); break;
            case "lint": this._cmdLint(); break;
            case "pack": this._cmdPack(); break;
            case "precompile": this._cmdPrecompile(); break;
            case "test": this._cmdTest(); break;
            default:
                console.error(`Error: Unrecognised command '${name}'.`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute task function.
     * @param {string} name - Name of the task to execute.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    _executeTask(name) {
        console.task(`TASK ${name}`);
        let task = this.tasks[name];
        if(task !== null) {
            //console.log("Executing command: " + typeof task);
            task();
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Executes the named command or task.
     * @param {string} name - Name of the command or task to execute.
     * @returns {Object} - Returns self for chaining.
     */
    execute(name) {
        if(this.commands.includes(name)) {
            this._executeCmd(name);
        } else if(Object.keys(this.tasks).includes(name)) {
            this._executeTask(name);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute command from the CLI.
     * @param {string} args - Arguments passed from the command line interface.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    cli(args) {
        console.log(color.inverse(`WARHORSE active.`));
        let [cmdName, convention="module"] = args;

        console.cmd(`COMMAND ${cmdName}`);

        // Handle built-ins
        if(cmdName === "init") {
            if(this.conventions.includes(convention)) {
                this._cmdInit(convention);
            } else {
                console.error(`Error: Unrecognised project convention: '${convention}'.`);
            }
            return null; // Success or fail - nothing to return.
        } else if(cmdName === "create") {
            if(this.conventions.includes(convention)) {
                this._cmdCreate(convention);
            } else {
                console.error(`Error: Unrecognised project convention: '${convention}'.`);
            }
            return null; // Success or fail - nothing to return.
        } else if(cmdName === "lint") {
            this._cmdLint();
            return null; // Success or fail - nothing to return.
        }

        // Handle user-definables
        let cmd = this.cmds[cmdName];
        if(cmd !== null) {
            //console.log("Executing command type: " + typeof cmd);
            cmd();
        }

        console.log(color.inverse(`WARHORSE done.`));

        // Return self for chaining.
        return this;
    }
}

// Exports
module.exports = Warhorse;

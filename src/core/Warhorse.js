/**
 * @file Warhorse.js
 * @description The main Warhorse daemon.
 * @author Kyle Alexis Sargeant <kasargeant@gmail.com> {@link https://github.com/kasargeant https://github.com/kasargeant}.
 * @copyright Kyle Alexis Sargeant 2017
 * @license See LICENSE file included in this distribution.
 */

"use strict";

// Imports
const child = require("child_process");
const fs = require("fs");
const path = require("path");
const zlib = require("zlib");

const glob = require("glob");
const shell = require("shelljs");

const browserify = require("browserify");
const csso = require("csso");
//const less = require("less");
const sass = require("node-sass");
const uglify = require("uglify-js");

// Setup console
const chalk = require("chalk");
const log = console.log;
const logTask = function(value)    {console.log(chalk.bgBlue(" " + value));};
const logAction = function(value)    {console.log(chalk.blue(" - " + value));};
const logStage = function(value)   {console.log(chalk.cyan("   -> " + value));};
const logWarning = function(value) {console.warn(chalk.yellow(value));};
const logError = function(value)   {console.error(chalk.red(value));};


/**
 * @class
 * @classdesc The main Warhorse class, containing all actions available to automate tasks and builds.
 */
class Warhorse {
    /**
     * The Warhorse constructor takes an options object.  In these options are contained the user requested
     * configuration defaults for the project.  If there are no options - then Warhorse's own default
     * configuration settings will be used instead.
     * @constructor
     * @param {Object} options - Configuration options to override Warhorse's own defaults.
     */
    constructor(options = {}) {
        this.defaults = {
            directory: process.cwd(),

            bundle: {
                transpile: true
            },
            clean: {},
            document: {
                src: "./src",
                dst: "./docs/api"
            },
            init: {
                name: "Untitled",
                version: "0.0.0",
                description: "A new project generated by the Warhorse task runner.",
                keywords: ["javascript"],
                author: "Unknown",
                email: "unknown@nowhere.com",
                license: "GPL-3.0"
            },
            load: {
                encoding: "utf8"
            },
            minify: {},
            pack: {
                gif: {},
                jpg: {},
                png: {},
                svg: {}
            },
            precompile: {
                includePaths: ["./src/sass"]
            },
            rename: {},
            save: {
                compress: false,
                encoding: "utf8"
            }
        };

        this.settings = Object.assign(this.defaults, options);

        this.cmds = {}; // Lookup for built-in commands.
        this.tasks = {}; // Lookup for user-defined tasks.

        this.file = null; // Main arg passed from function to function - requires sync operation of course!

    }

    /**
     * Bundle action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    bundle(options = {}) {

        // Handle task configuration.
        let config = Object.assign(this.settings.bundle, options);

        logAction(`Bundling file from: ${this.file.path}`);

        // Process the data.
        // NOTE: Shell process used in order to force sync behaviour.
        // Determine if we're transpiling as well as bundling... or just bundling?
        if(config.transpile === true) {
            // Transpile then bundle
            //let processed = child.execSync(`browserify --debug -t [babelify]`, {input: this.file.path});
            let processed = child.execSync(`browserify --debug ${this.file.path} -t [babelify]`);
            this.file.content = processed.toString();
            //console.log(`stdout: ${this.file.content}`);
        } else {
            // Just bundle
            let processed = child.execSync(`browserify --debug ${this.file.path}`);
            this.file.content = processed.toString();
            //console.log(`stdout: ${this.file.content}`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Bundle action.
     * @param {Array} paths - Array of paths or files to empty and delete.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    clean(paths, options = {}) {
        logAction(`Cleaning project of generated files.`);
        shell.rm("-rf", ...paths);
        logStage(`Done.`);
    }


    /**
     * Compile LESS action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    compileLESS(options = {}) {

        logAction(`Compiling LESS from: ${this.file.path}`);

        let config = Object.assign(this.settings.precompile, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        // NOTE: Shell process used in order to force sync behaviour.
        let processed = child.execSync(`lessc --relative-urls --include-path=${this.file.path} ${this.file.path + this.file.name}`);
        this.file.content = processed.toString();

        // Transform the extension
        this.file.extension = ".css";
        this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;

        //config example
        // let lessrc = {
        //     env: "development",
        //     logLevel: 2,
        //     async: false,
        //     fileAsync: false,
        //     poll: 1000,
        //     functions: {},
        //     dumpLineNumbers: "comments",
        //     relativeUrls: true,
        //     includePaths: ["./test/data/client_src/less/"],
        //     globalVars: {
        //         var1: '"string value"',
        //         var2: 'regular value'
        //     },
        //     rootpath: ":/a.com/"
        // };
    }

    /**
     * Compile SCSS(SASS) action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    compileSASS(options = {}) {

        logAction(`Compiling SCSS from: ${this.file.path}`);

        let config = Object.assign(this.settings.precompile, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        let processed = sass.renderSync(config).css;
        this.file.content = processed.toString();

        // Transform the extension
        this.file.extension = ".css";
        this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }

    /**
     * Create project convention action.
     * @param {Object} file - File to be processed by this action.
     * @param {Function} next - The next callback action to be executed after this one.
     * @param {Object} options - Options to further configure this action.
     * @returns {void}
     * @private - until implemented!
     */
    init(file, next, options = {}) {
        //
        // // Resolve configuration
        // let config = Object.assign(this.settings.init, options);
        //
        // // Create NPM package configuration
        // const packageDefault = require("../default/package.json");
        // let packageProject = Object.assign(packageDefault, config);
        //
        // let convention = "default";
        // console.log(` * Creating project from convention: ${convention}`);
        // console.log(`   - Working directory: ${process.cwd()}`);
        //
        // // Fault-tolerant version of fs.mkdirSync(dirPath) - won't overwrite existing dirs!!!
        // const mkdirSync = function(dirPath) {
        //     try {
        //         fs.mkdirSync(dirPath);
        //     } catch(err) {
        //         if(err.code !== "EEXIST") {throw err;};
        //     }
        // };
        //
        // // Fault-tolerant version of fs.unlinkSync(filePath) - won't crash if no file already exists!!!
        // const unlinkSync = function(filePath) {
        //     try {
        //         fs.unlinkSync(filePath);
        //     } catch(err) {
        //         console.error(err.code);
        //         // if(err.code !== "EEXIST") {throw err};
        //     }
        // };
        //
        // // Create project directory structure
        // //FIXME - Guard can be removed once function is fully implemented.
        // let workingDirectory = this.settings.directory;
        // if(workingDirectory === "/Users/kasargeant/dev/projects/warhorse") {
        //     mkdirSync("./temp");
        //
        //     mkdirSync("./temp/conf");
        //
        //     mkdirSync("./temp/dist");
        //
        //     mkdirSync("./temp/docs");
        //     mkdirSync("./temp/docs/api");
        //     mkdirSync("./temp/docs/coverage");
        //     mkdirSync("./temp/docs/tests");
        //     mkdirSync("./temp/docs/linters");
        //
        //     mkdirSync("./temp/src");
        //     mkdirSync("./temp/src/css");
        //     mkdirSync("./temp/src/img");
        //     mkdirSync("./temp/src/js");
        //
        //     mkdirSync("./temp/test");
        //
        //     // Write NPM package definition
        //     let packageJson = JSON.stringify(packageProject, null, 4);
        //     unlinkSync("./temp/package.json");
        //     fs.writeFileSync("./temp/package.json", packageJson, "utf8");
        //     console.log(packageJson);
        //
        //     // Create configuration files
        //     const configJSCS = require("../default/conf/jscsrc.json");
        //     fs.writeFileSync("./temp/conf/.jscsrc", JSON.stringify(configJSCS, null, 4));
        //
        //     const configJSHINT = require("../default/conf/jshintrc.json");
        //     fs.writeFileSync("./temp/conf/.jshintrc", JSON.stringify(configJSHINT, null, 4));
        // }


        // Return self for chaining.
        return this;
    }

    /**
     * Document JS API action.  Documents JavaScript from src/ folder(s).
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    documentJS(options = {}) {

        let config = Object.assign(this.settings.document, options);

        logAction(`Documenting file(s) from: ${config.src}`);
        logStage(`to path: ${config.dst}`);

        child.execSync(`jsdoc -r -c ./conf/.jsdocrc`);
        // child.execSync(`jsdoc ${config.src} -r -c ./conf/.jsdocrc -d ${config.dst}`);

        // Return self for chaining.
        return this;
    }

    /**
     * Load action.  Loads files being used for processing by the action that follows.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    load(options = {}) {

        logAction(`Loading file: ${this.file.name + this.file.name}`);

        let config = Object.assign(this.settings.load, options);

        // Accepts a single filepath only.
        let srcPath = this.file.path + this.file.name;
        //logStage(`from path: ${srcPath}`);

        this.file.content = fs.readFileSync(srcPath, config.encoding);

        // Return self for chaining.
        return this;
    }

    /**
     * Minify CSS action.  Minimisation for standard CSS.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    minifyCSS(options = {}) {

        logAction(`Minifying CSS from: ${this.file.path}`);

        let config = Object.assign(this.settings.minify, options);

        this.file.content = csso.minify(this.file.content).css;

        // Return self for chaining.
        return this;
    }

    /**
     * Minify JS action.  Minimisation for ES51/ES2015 JavaScript.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    minifyJS(options = {}) {

        logAction(`Minifying JS from: ${this.file.path}`);

        let config = Object.assign(this.settings.bundle, options);
        config.fromString = true; // Essential for data input
        
        // Process the data
        let processed = uglify.minify({"file": this.file.content}, config).code;
        this.file.content = processed.toString();

        // Return self for chaining.
        return this;
    }

    /**
     * Pack GIF asset action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    packGIF(options = {}) {

        logAction(`Packing GIF from: ${this.file.path + this.file.name}`);

        let config = Object.assign(this.settings.pack.gif, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        // NOTE: Shell process used in order to force sync behaviour.
        let processed = child.execSync(`imagemin --plugin=gifsicle --optimizationLevel=2`, {
            input: this.file.content,
            encoding: "binary"
        });
        this.file.content = processed;

        // Transform the extension
        // this.file.extension = ".css";
        // this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }

    /**
     * Pack JPG asset action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    packJPG(options = {}) {

        logAction(`Packing JPG from: ${this.file.path + this.file.name}`);

        let config = Object.assign(this.settings.pack.jpg, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        // NOTE: Shell process used in order to force sync behaviour.
        let processed = child.execSync(`imagemin --plugin=jpegtran`, {
            input: this.file.content,
            encoding: "binary"
        });
        this.file.content = processed;

        // Transform the extension
        // this.file.extension = ".css";
        // this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }

    /**
     * Pack PNG asset action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    packPNG(options = {}) {

        logAction(`Packing PNG from: ${this.file.path + this.file.name}`);

        let config = Object.assign(this.settings.pack.png, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        // NOTE: Shell process used in order to force sync behaviour.
        let processed = child.execSync(`imagemin --plugin=pngquant --quality=75`, {
            input: this.file.content,
            encoding: "binary"
        });
        this.file.content = processed;

        // Transform the extension
        // this.file.extension = ".css";
        // this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }
    
    /**
     * Pack SVG asset action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    packSVG(options = {}) {

        logAction(`Packing SVG from: ${this.file.path + this.file.name}`);

        let config = Object.assign(this.settings.pack.svg, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        // NOTE: Shell process used in order to force sync behaviour.
        let processed = child.execSync(`imagemin --plugin=svgo`, {
            input: this.file.content
        });
        this.file.content = processed;

        // Transform the extension
        // this.file.extension = ".css";
        // this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }
    
    /**
     * Rename action.  Allows modification/replacement/injection of file details into the sequence of actions.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    rename(options = {}) {

        logAction(`Renaming file: ${this.file.path}`);

        let config = Object.assign(this.settings.save, options);

        // Rename (i.e. overwrite) any values in the file object with the user-defined options object
        this.file = Object.assign(this.file, config);

        // Return self for chaining.
        return this;
    }

    /**
     * Splits a file path into its component parts.
     * @param {string} filePath - A standard system file or path name.
     * @returns {Object} - An object containing a destructured hash of the path's parts.
     * @private
     */
    _splitPath(filePath) {

        // Sanity check
        if(!filePath) {return null;}

        //logStage(`Splitting file path: ${filePath}`); // e.g. /docs/index.html  // DEBUG ONLY

        let name = path.posix.basename(filePath);           // e.g. index.html
        let directory = path.dirname(filePath) + "/";       // e.g. /docs/
        let stem = name.slice(0, name.lastIndexOf("."));    // e.g. index
        let extension = path.extname(filePath);             // e.g. .html

        // console.log(`name: ${name}`);
        // console.log(`directory: ${directory}`);
        // console.log(`stem: ${stem}`);
        // console.log(`extension: ${extension}`);

        // Is it a config file e.g. .jshintrc
        let config = false;
        if(extension === "" && name.length > 0 && name[0] === "." && name.slice(-2) === "rc") {
            config = true;
        }
        return {
            original: filePath,
            path: directory, // Note: We use 'directory' to avoid nameclash with the module of the same name.
            name: name,
            stem: stem,
            extension: extension,
            config: config
        };
    }

    /**
     * Save action.
     * @param {string} dstPath - The file path that this file will be saved to.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    save(dstPath, options = {}) {

        let config = Object.assign(this.settings.save, options);

        logAction(`Saving file to: ${dstPath}`);

        if(config.compress === true) {
            let data = zlib.gzipSync(this.file.content);
            fs.writeFileSync(dstPath + ".gz", data, config.encoding);
        } else {
            fs.writeFileSync(dstPath, this.file.content, config.encoding);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Command 'wrapper' function.  Wraps a task, or list of tasks, to be executed by the named command.
     * @param {string} name - Name of the task.
     * @param {string} cmdFn - A function containing the tasks executed for this command.
     * @returns {void}
     */
    cmd(name, cmdFn) {
        this.cmds[name] = cmdFn;
    }

    /**
     * Task 'wrapper' function.  Wraps an action, or list of actions, to be followed by the named task.
     * @param {string} name - Name of the task.
     * @param {string} taskFn - A function containing the actions followed for the task.
     * @returns {void}
     */
    task(name, taskFn) {
        this.tasks[name] = taskFn;
    }

    /**
     * Private helper for load().
     * @param {string} globPath - A filename, filepath or globpath.
     * @param {Function} task - The task to be executed.
     * @returns {void}
     * @private
     */
    _use(globPath, task) {
        //logAction(`Parsing: ${globPath}`);

        // Sync filesystem check
        let filePaths = glob.sync(globPath);
        if(filePaths.constructor === Array && filePaths.length > 0) {
            for(let filePath of filePaths) {
                this.file = this._splitPath(filePath);
                task();
            }
        } else {
            logWarning("No files matched.");
        }
    }

    /**
     * Use function identfies which files are to be used with which task
     * @param {string} taskName - The name of the task to be executed for every batch item.
     * @param {string} filePath - File path (globs/wildcards allowed) to be processed by this action.
     * @param {Object} options - Options to further configure this action.
     * @returns {Object} - Returns self for chaining.
     */
    use(taskName, filePath = "index.html", options = {}) {

        logTask(`TASK: ${taskName}`);

        // Retrieve task from the taskName
        let task = this.tasks[taskName];

        // If it is a batch of filePaths...
        if(filePath.constructor === Array) {
            filePath.map(function(filePathItem) {
                this._use(filePathItem, task);}.bind(this)
            );
        }

        // Else if it is single filePath.
        else if(typeof filePath === "string") {
            this._use(filePath, task);
        }
        // Otherwise...
        else {
            console.error(`Error: Unrecognisable or null filepath: ${filePath}`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute task function.
     * @param {string} taskName - Name of the task.
     * @returns {Object} - Returns self for chaining.
     */
    execute(taskName) {
        logTask(`TASK ${taskName}`);
        let task = this.tasks[taskName];
        if(task !== null) {
            //console.log("Executing command: " + typeof task);
            task();
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute command function.
     * @param {string} cmdName - Name of the task.
     * @returns {Object} - Returns self for chaining.
     * @private
     */
    executeCommand(cmdName) {
        logTask(`COMMAND ${cmdName}`);
        let cmd = this.cmds[cmdName];
        if(cmd !== null) {
            //console.log("Executing command type: " + typeof cmd);
            cmd();
        }

        // Return self for chaining.
        return this;
    }
}

// Exports
module.exports = Warhorse;

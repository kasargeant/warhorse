"use strict";

// Imports
const child = require("child_process");
const fs = require("fs");
const path = require("path");
const zlib = require("zlib");

const glob = require("glob");

const browserify = require("browserify");
const csso = require("csso");
const less = require("less");
const sass = require("node-sass");
const uglify = require("uglify-js");

// Setup console
const chalk = require("chalk");
const log = console.log;
const logTask = function(value)    {console.log(chalk.bgBlue(" " + value));};
const logAction = function(value)    {console.log(chalk.blue(" - " + value));};
const logStage = function(value)   {console.log(chalk.yellow("   -> " + value));};
const logWarning = function(value) {console.warn(chalk.orange(value));};
const logError = function(value)   {console.error(chalk.red(value));};


/**
 * @class
 * @classdesc The main Warhorse class, containing all actions available to automate tasks and builds.
 */
class Warhorse {
    /**
     * The Warhorse constructor takes an options object.  In these options are contained the user requested
     * configuration defaults for the project.  If there are no options - then Warhorse's own default
     * configuration settings will be used instead.
     * @constructor
     * @param {Object} options - Configuration options to override Warhorse's own defaults.
     */
    constructor(options = {}) {
        this.defaults = {
            directory: process.cwd(),
            document: {
                src: "./src",
                dst: "./docs/api"
            },
            init: {
                name: "Untitled",
                version: "0.0.0",
                description: "A new project generated by the Warhorse task runner.",
                keywords: ["javascript"],
                author: "Unknown",
                email: "unknown@nowhere.com",
                license: "GPL-3.0"
            },
            bundle: {
                transpile: true
            },
            precompile: {
                includePaths: ["./src/sass"]
            },
            minify: {},
            rename: {},
            save: {
                compress: false
            }
        };

        this.settings = Object.assign(this.defaults, options);

        this.tasks = {}; // Lookup for user-defined tasks.

        this.file = null; // Main arg passed from function to function - requires sync operation of course!

    }

    /**
     * Bundle function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    bundle(options = {}) {

        // Handle task configuration.
        let config = Object.assign(this.settings.bundle, options);

        logAction(`Bundling file from: ${this.file.path}`);

        // Determine if we're transpiling as well as bundling... or just bundling?
        if(config.transpile === true) {
            // Transpile then bundle
            let processed = child.execSync(`browserify --debug ${this.file.path} -t [babelify]`);
            //#1 let processed = child.execSync(`browserify --debug -t [babelify]`, {input: this.file.path});
            ////let processed = child.execSync(`| browserify --debug -t [babelify]`, {input: this.file.content});
            this.file.content = processed.toString();

            //console.log(`stdout: ${this.file.content}`);
        } else {
            // Just bundle
            let processed = child.execSync(`browserify --debug ${this.file.path}`);
            this.file.content = processed.toString();
            //console.log(`stdout: ${this.file.content}`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Compile LESS function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    compileLESS(options = {}) {

        logAction(`Compiling LESS from: ${this.file.path}`);

        let config = Object.assign(this.settings.precompile, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        let processed = child.execSync(`lessc --relative-urls --include-path=${this.file.path} ${this.file.path + this.file.name}`);
        this.file.content = processed.toString();

        // Transform the extension
        this.file.extension = ".css";
        this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;

        //config example
        // let lessrc = {
        //     env: "development",
        //     logLevel: 2,
        //     async: false,
        //     fileAsync: false,
        //     poll: 1000,
        //     functions: {},
        //     dumpLineNumbers: "comments",
        //     relativeUrls: true,
        //     includePaths: ["./test/shared/client_src/less/"],
        //     globalVars: {
        //         var1: '"string value"',
        //         var2: 'regular value'
        //     },
        //     rootpath: ":/a.com/"
        // };
    }

    /**
     * Compile SCSS(SASS) function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    compileSASS(options = {}) {

        logAction(`Compiling SCSS from: ${this.file.path}`);

        let config = Object.assign(this.settings.precompile, options);

        config.data = this.file.content;         // e.g. index.scss
        config.includePaths = [this.file.path];  // e.g. ./src/sass
        // ALTERNATIVE config.file = file.path + "/" + file.name;

        // Process the data
        let processed = sass.renderSync(config).css;
        this.file.content = processed.toString();

        // Transform the extension
        this.file.extension = ".css";
        this.file.name = this.file.stem + this.file.extension;

        // Return self for chaining.
        return this;
    }

    /**
     * Create project convention function.
     * @param {Object} file - File to be processed by this action.
     * @param {Function} next - The next callback action to be executed after this one.
     * @param {Object} options - Options to further configure this action.
     * @returns {void}
     */
    init(file, next, options = {}) {

        // Resolve configuration
        let config = Object.assign(this.settings.init, options);

        // Create NPM package configuration
        const packageDefault = require("../default/package.json");
        let packageProject = Object.assign(packageDefault, config);

        let convention = "default";
        console.log(` * Creating project from convention: ${convention}`);
        console.log(`   - Working directory: ${process.cwd()}`);

        // Fault-tolerant version of fs.mkdirSync(dirPath) - won't overwrite existing dirs!!!
        const mkdirSync = function(dirPath) {
            try {
                fs.mkdirSync(dirPath);
            } catch(err) {
                if(err.code !== "EEXIST") {throw err;};
            }
        };

        // Fault-tolerant version of fs.unlinkSync(filePath) - won't crash if no file already exists!!!
        const unlinkSync = function(filePath) {
            try {
                fs.unlinkSync(filePath);
            } catch(err) {
                console.error(err.code);
                // if(err.code !== "EEXIST") {throw err};
            }
        };

        // Create project directory structure
        //FIXME - Guard can be removed once function is fully implemented.
        let workingDirectory = this.settings.directory;
        if(workingDirectory === "/Users/kasargeant/dev/projects/warhorse") {
            mkdirSync("./temp");

            mkdirSync("./temp/conf");

            mkdirSync("./temp/dist");

            mkdirSync("./temp/docs");
            mkdirSync("./temp/docs/api");
            mkdirSync("./temp/docs/coverage");
            mkdirSync("./temp/docs/tests");
            mkdirSync("./temp/docs/linters");

            mkdirSync("./temp/src");
            mkdirSync("./temp/src/css");
            mkdirSync("./temp/src/img");
            mkdirSync("./temp/src/js");

            mkdirSync("./temp/test");

            // Write NPM package definition
            let packageJson = JSON.stringify(packageProject, null, 4);
            unlinkSync("./temp/package.json");
            fs.writeFileSync("./temp/package.json", packageJson, "utf8");
            console.log(packageJson);
            
            // Create configuration files
            const configJSCS = require("../default/conf/jscsrc.json");
            fs.writeFileSync("./temp/conf/.jscsrc", JSON.stringify(configJSCS, null, 4));

            const configJSHINT = require("../default/conf/jshintrc.json");
            fs.writeFileSync("./temp/conf/.jshintrc", JSON.stringify(configJSHINT, null, 4));
        }

        // Is there a callback function or shall we just return the value?
        if(next !== undefined && typeof next === "function") {
            // Yes - Pass file result onto the next function.
            next(file);
            return null; // XXX: Pointless null, required by jsdoc.
        } else {
            // No - Then return file result directly.
            return file;
        }
    }

    /**
     * Document function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    document(options = {}) {

        let config = Object.assign(this.settings.document, options);

        logAction(`Documenting file(s) from: ${config.src}`);
        logStage(`to path: ${config.dst}`);

        child.execSync(`jsdoc -r -c ./conf/.jsdocrc`);
        // child.execSync(`jsdoc ${config.src} -r -c ./conf/.jsdocrc -d ${config.dst}`);

        // Return self for chaining.
        return this;
    }

    /**
     * Load function
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    load(options = {}) {

        logAction(`Loading file: ${this.file.name}`);

        // Accepts a single filepath only.
        let srcPath = this.file.path + this.file.name;
        logStage(`from path: ${srcPath}`);

        this.file.content = fs.readFileSync(srcPath, "utf8");

        // Return self for chaining.
        return this;
    }

    /**
     * Minify CSS function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    minifyCSS(options = {}) {

        logAction(`Minifying CSS from: ${this.file.path}`);

        let config = Object.assign(this.settings.minify, options);

        this.file.content = csso.minify(this.file.content).css;

        // Return self for chaining.
        return this;
    }

    /**
     * Minify JS function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    minifyJS(options = {}) {

        logAction(`Minifying JS from: ${this.file.path}`);

        let config = Object.assign(this.settings.bundle, options);

        // Process the data
        let processed = uglify.minify({"file": this.file.content}, {
            fromString: true
        }).code;
        this.file.content = processed.toString();

        // Return self for chaining.
        return this;
    }

    /**
     * Rename function.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    rename(options = {}) {

        logAction(`Renaming file: ${this.file.path}`);

        let config = Object.assign(this.settings.save, options);

        // Rename (i.e. overwrite) any values in the file object with the user-defined options object
        this.file = Object.assign(this.file, options);

        // Return self for chaining.
        return this;
    }

    /**
     * Splits a file path into its component parts.
     * @param {string} filePath - A standard system file or path name.
     * @returns {Object} - An object containing a destructured hash of the path's parts.
     * @private
     */
    _splitPath(filePath) {

        // Sanity check
        if(!filePath) {return null;}

        logStage(`Splitting file path: ${filePath}`); // e.g. /docs/index.html

        let name = path.posix.basename(filePath);           // e.g. index.html
        let directory = path.dirname(filePath) + "/";       // e.g. /docs/
        let stem = name.slice(0, name.lastIndexOf("."));    // e.g. index
        let extension = path.extname(filePath);             // e.g. .html

        // console.log(`name: ${name}`);
        // console.log(`directory: ${directory}`);
        // console.log(`stem: ${stem}`);
        // console.log(`extension: ${extension}`);

        // Is it a config file e.g. .jshintrc
        let config = false;
        if(extension === "" && name.length > 0 && name[0] === "." && name.slice(-2) === "rc") {
            config = true;
        }
        return {
            original: filePath,
            path: directory, // Note: We use 'directory' to avoid nameclash with the module of the same name.
            name: name,
            stem: stem,
            extension: extension,
            config: config
        };
    }

    /**
     * Save function.
     * @param {string} dstPath - The file path that this file will be saved to.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    save(dstPath, options = {}) {

        let config = Object.assign(this.settings.save, options);

        logAction(`Saving file to: ${dstPath}`);

        if(config.compress === true) {
            let data = zlib.gzipSync(this.file.content);
            fs.writeFileSync(dstPath + ".gz", data, "utf8");
        } else {
            fs.writeFileSync(dstPath, this.file.content, "utf8");
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Task 'wrapper' function.
     * @param {string} name - Name of the task.
     * @param {string} taskFunction - An anonymous function containing the actions involved in the task.
     * @returns {void}
     */
    task(name, taskFunction) {
        this.tasks[name] = taskFunction;
    }




    /**
     * Private helper for load().
     * @param {string} globPath
     * @param {string} task - The task to be executed.
     * @private
     */
    _use(globPath, task) {
        logAction(`Parsing: ${globPath}`);

        // Sync filesystem check
        let filePaths = glob.sync(globPath);
        if(filePaths.constructor === Array && filePaths.length > 0) {
            for(let filePath of filePaths) {
                this.file = this._splitPath(filePath);
                logStage(`Handling file from: ${this.file.name}`);
                task();
            }
        } else {
            logWarning("No files matched.");
        }
    }

    /**
     * Use function identfies which files are to be used with which task
     * @param {string} filePath - File path (globs/wildcards allowed) to be processed by this action.
     * @param {string} taskName - The name of the task to be executed for every batch item.
     * @param {Object} options - Options to further configure this action.
     * @returns {this} - Returns self for chaining.
     */
    use(taskName, filePath, options = {}) {

        // Retrieve task from the taskName
        let task = this.tasks[taskName];

        // If it is a batch of filePaths...
        if(filePath.constructor === Array) {
            filePath.map(function(filePathItem) {
                this._use(filePathItem, task);}.bind(this)
            );
        }

        // Else if it is single filePath.
        else if(typeof filePath === "string") {
            this._use(filePath, task);
        }
        // Otherwise...
        else {
            console.error(`Error: Unrecognisable or null filepath: ${filePath}`);
        }

        // Return self for chaining.
        return this;
    }

    /**
     * Execute task function.
     * @param {string} name - Name of the task.
     * @returns {void}
     */
    execute(taskName) {
        logTask(`TASK ${taskName}`);
        let task = this.tasks[taskName];
        if(task !== null) {
            //console.log("Executing command: " + typeof task);
            task();
        }
    }
}

// Exports
module.exports = Warhorse;
